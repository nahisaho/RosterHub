# Default values for rosterhub
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# Global settings
global:
  namespace: rosterhub

# API application settings
api:
  name: rosterhub-api
  replicaCount: 2

  image:
    repository: rosterhub/api
    pullPolicy: IfNotPresent
    tag: "latest"

  imagePullSecrets: []

  serviceAccount:
    create: true
    annotations: {}
    name: "rosterhub-api"

  podAnnotations: {}

  podSecurityContext:
    fsGroup: 1000

  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1000

  service:
    type: ClusterIP
    port: 80
    targetPort: 3000

  ingress:
    enabled: true
    className: "nginx"
    annotations:
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      nginx.ingress.kubernetes.io/enable-cors: "true"
      nginx.ingress.kubernetes.io/cors-allow-origin: "*"
      nginx.ingress.kubernetes.io/limit-rps: "100"
      nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    hosts:
      - host: api.rosterhub.example.com
        paths:
          - path: /
            pathType: Prefix
    tls:
      - secretName: rosterhub-api-tls
        hosts:
          - api.rosterhub.example.com

  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "512Mi"
      cpu: "500m"

  autoscaling:
    enabled: true
    minReplicas: 2
    maxReplicas: 10
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80
    metrics:
      - type: Pods
        pods:
          metric:
            name: http_requests_per_second
          target:
            type: AverageValue
            averageValue: "1000"
    behavior:
      scaleDown:
        stabilizationWindowSeconds: 300
        policies:
          - type: Percent
            value: 50
            periodSeconds: 60
      scaleUp:
        stabilizationWindowSeconds: 0
        policies:
          - type: Percent
            value: 100
            periodSeconds: 30

  podDisruptionBudget:
    enabled: true
    minAvailable: 1

  nodeSelector: {}

  tolerations: []

  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
                - key: app
                  operator: In
                  values:
                    - rosterhub-api
            topologyKey: kubernetes.io/hostname

  livenessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3

  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

  volumeMounts:
    - name: tmp
      mountPath: /tmp
    - name: cache
      mountPath: /app/.cache

  volumes:
    - name: tmp
      emptyDir: {}
    - name: cache
      emptyDir: {}

  # Init container for database migrations
  initContainers:
    migrate:
      enabled: true
      command: ["npx", "prisma", "migrate", "deploy"]

# Application configuration (ConfigMap)
config:
  nodeEnv: "production"
  logLevel: "info"
  swaggerEnabled: "true"
  debugHttpLogging: "false"
  databaseQueryLogging: "false"
  corsAllowedOrigins: "*"
  rateLimitDefault: "1000"
  rateLimitAuth: "10"
  rateLimitMaxFileSize: "50"
  auditLogRetentionDays: "90"
  fileUploadMaxSize: "52428800"  # 50MB
  fileUploadAllowedMimeTypes: "text/csv,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  csvImportMaxRows: "50000"
  csvImportChunkSize: "1000"
  bulkOperationMaxItems: "1000"
  bulkOperationBatchSize: "100"
  webhookRetryAttempts: "3"
  webhookRetryDelay: "1000"
  webhookTimeout: "30000"
  cacheEnabled: "true"
  cacheTtlDefault: "300"
  cacheTtlUsers: "600"
  cacheTtlOrgs: "1800"
  onerosterVersion: "1.2.2"
  onerosterProfile: "japan"
  onerosterEnableDelta: "true"
  onerosterDeltaPageSize: "100"

# Secrets (should be provided via external secret manager in production)
secrets:
  # Database
  databaseUrl: ""  # postgresql://user:password@postgres:5432/rosterhub

  # Redis
  redisUrl: ""  # redis://:password@redis:6379

  # JWT
  jwtSecret: ""  # openssl rand -base64 32
  jwtExpiresIn: "1h"
  jwtRefreshExpiresIn: "7d"

  # PostgreSQL (for StatefulSet)
  postgresUser: "rosterhub"
  postgresPassword: ""  # openssl rand -base64 32
  postgresDb: "rosterhub"

  # Redis (for StatefulSet)
  redisPassword: ""  # openssl rand -base64 32

# PostgreSQL StatefulSet
postgresql:
  enabled: true
  name: postgres

  image:
    repository: postgres
    tag: "15-alpine"
    pullPolicy: IfNotPresent

  persistence:
    enabled: true
    storageClass: "standard"
    size: 20Gi
    accessMode: ReadWriteOnce

  resources:
    requests:
      memory: "256Mi"
      cpu: "100m"
    limits:
      memory: "1Gi"
      cpu: "1000m"

  livenessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3

  readinessProbe:
    exec:
      command:
        - /bin/sh
        - -c
        - pg_isready -U $POSTGRES_USER
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3

  service:
    type: ClusterIP
    port: 5432

  # PostgreSQL configuration
  config:
    maxConnections: "100"
    sharedBuffers: "256MB"
    effectiveCacheSize: "1GB"
    maintenanceWorkMem: "64MB"
    checkpointCompletionTarget: "0.9"
    walBuffers: "16MB"
    defaultStatisticsTarget: "100"
    randomPageCost: "1.1"
    effectiveIoConcurrency: "200"
    workMem: "2621kB"
    minWalSize: "1GB"
    maxWalSize: "4GB"
    maxWorkerProcesses: "4"
    maxParallelWorkersPerGather: "2"
    maxParallelWorkers: "4"
    maxParallelMaintenanceWorkers: "2"
    logMinDurationStatement: "1000"
    logLinePrefix: "'%t [%p]: '"
    logTimezone: "UTC"
    timezone: "UTC"

# Redis StatefulSet
redis:
  enabled: true
  name: redis

  image:
    repository: redis
    tag: "7-alpine"
    pullPolicy: IfNotPresent

  persistence:
    enabled: true
    storageClass: "standard"
    size: 5Gi
    accessMode: ReadWriteOnce

  resources:
    requests:
      memory: "128Mi"
      cpu: "50m"
    limits:
      memory: "512Mi"
      cpu: "500m"

  livenessProbe:
    exec:
      command:
        - redis-cli
        - ping
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 3

  readinessProbe:
    exec:
      command:
        - redis-cli
        - ping
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    successThreshold: 1
    failureThreshold: 3

  service:
    type: ClusterIP
    port: 6379

  # Redis configuration
  config:
    maxmemory: "256mb"
    maxmemoryPolicy: "allkeys-lru"
    appendonly: "yes"
    appendfsync: "everysec"
    autoAofRewritePercentage: "100"
    autoAofRewriteMinSize: "64mb"
    save: "900 1 300 10 60 10000"
    stopWritesOnBgsaveError: "yes"
    rdbcompression: "yes"
    rdbchecksum: "yes"
    databases: "16"
    timeout: "300"
    tcpKeepalive: "300"
    logLevel: "notice"
